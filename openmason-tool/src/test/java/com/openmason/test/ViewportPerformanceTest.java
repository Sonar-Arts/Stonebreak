package com.openmason.test;

import com.openmason.rendering.PerformanceOptimizer;
import com.openmason.rendering.BufferManager;
import com.openmason.camera.ArcBallCamera;
import com.openmason.test.mocks.MockOpenGLContext;
import com.openmason.test.performance.PerformanceBenchmark;
import com.openmason.test.performance.FrameRateBenchmarkResult;
import com.openmason.test.performance.MemoryBenchmarkResult;
import com.openmason.test.performance.PerformanceValidationResult;

import org.junit.jupiter.api.*;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.junit.jupiter.params.provider.CsvSource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Comprehensive performance testing for the OpenMason 3D viewport system.
 * 
 * This test class validates that the Phase 3 viewport implementation meets
 * professional performance requirements under various conditions:
 * - Frame rate consistency at 60 FPS target
 * - Memory usage efficiency and leak prevention
 * - Adaptive quality scaling effectiveness
 * - Performance under different workloads
 * - Stress testing and degradation characteristics
 */
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class ViewportPerformanceTest {
    
    private static final Logger logger = LoggerFactory.getLogger(ViewportPerformanceTest.class);
    
    // Performance test infrastructure
    private PerformanceBenchmark benchmark;
    private MockOpenGLContext mockOpenGLContext;
    
    // Components under test
    private PerformanceOptimizer performanceOptimizer;
    private ArcBallCamera camera;
    private BufferManager bufferManager;
    
    // Test configuration
    private static final double[] TEST_WORKLOADS = {0.5, 1.0, 2.0, 5.0, 10.0}; // Milliseconds per frame
    private static final int[] VIEWPORT_SIZES = {400, 800, 1200, 1920}; // Different resolutions
    
    @BeforeAll
    void setUpSuite() {
        logger.info("Setting up Viewport Performance Test Suite");
        
        // Initialize test infrastructure
        benchmark = new PerformanceBenchmark("ViewportPerformance");
        mockOpenGLContext = new MockOpenGLContext();
        
        // Configure system for performance testing
        System.setProperty("performance.test.mode", "true");
        System.setProperty("java.awt.headless", "true");
        
        logger.info("Viewport Performance Test Suite initialized");
    }
    
    @BeforeEach
    void setUp() {
        logger.debug("Setting up performance test");
        
        // Reset test infrastructure
        mockOpenGLContext.reset();
        benchmark.clearResults();
        
        // Initialize components
        performanceOptimizer = new PerformanceOptimizer();
        performanceOptimizer.setDebugPrefix("ViewportPerformanceTest");
        performanceOptimizer.setDebugMode(false); // Reduce logging overhead
        
        camera = new ArcBallCamera();
        bufferManager = BufferManager.getInstance();
        
        logger.debug("Performance test setup completed");
    }\n    \n    @AfterEach\n    void tearDown() {\n        logger.debug(\"Tearing down performance test\");\n        \n        // Cleanup components\n        if (performanceOptimizer != null) {\n            performanceOptimizer.setEnabled(false);\n        }\n        \n        logger.debug(\"Performance test teardown completed\");\n    }\n    \n    @AfterAll\n    void tearDownSuite() {\n        logger.info(\"Tearing down Viewport Performance Test Suite\");\n        \n        // Final cleanup\n        if (bufferManager != null) {\n            bufferManager.cleanup();\n        }\n        \n        logger.info(\"Viewport Performance Test Suite completed\");\n    }\n    \n    /**\n     * Tests baseline performance with minimal workload.\n     */\n    @Test\n    @DisplayName(\"Baseline Performance Test\")\n    void testBaselinePerformance() {\n        logger.info(\"Testing baseline viewport performance\");\n        \n        FrameRateBenchmarkResult result = benchmark.measureFrameRate(() -> {\n            performanceOptimizer.beginFrame();\n            \n            // Minimal rendering workload\n            mockOpenGLContext.beginFrame();\n            mockOpenGLContext.glViewport(0, 0, 800, 600);\n            mockOpenGLContext.glClear(0x00004100); // Clear buffers\n            mockOpenGLContext.endFrame();\n            \n            // Update camera (minimal computation)\n            camera.update(0.016f);\n            \n            performanceOptimizer.endFrame();\n        }, 3.0, \"Baseline performance (3 seconds)\");\n        \n        // Validate baseline performance\n        PerformanceValidationResult validation = benchmark.validatePerformance(result);\n        \n        assertTrue(validation.isAcceptable(), \"Baseline performance should be acceptable: \" + validation);\n        assertTrue(result.getAverageFPS() >= PerformanceBenchmark.TARGET_FPS * 0.9, \n                  \"Baseline FPS should be near target: \" + result.getAverageFPS());\n        assertTrue(result.getStandardDeviation() < 5.0, \n                  \"Frame time variance should be low: \" + result.getStandardDeviation());\n        \n        logger.info(\"Baseline performance test completed: {}\", result);\n    }\n    \n    /**\n     * Tests performance under various rendering workloads.\n     */\n    @ParameterizedTest\n    @ValueSource(doubles = {0.5, 1.0, 2.0, 5.0, 10.0})\n    @DisplayName(\"Variable Workload Performance\")\n    void testVariableWorkloadPerformance(double workloadMs) {\n        logger.info(\"Testing performance with {}ms workload\", workloadMs);\n        \n        FrameRateBenchmarkResult result = benchmark.measureFrameRate(() -> {\n            performanceOptimizer.beginFrame();\n            \n            mockOpenGLContext.beginFrame();\n            \n            // Simulate variable rendering workload\n            try {\n                Thread.sleep((long) workloadMs);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            \n            mockOpenGLContext.glViewport(0, 0, 800, 600);\n            mockOpenGLContext.glClear(0x00004100);\n            \n            mockOpenGLContext.endFrame();\n            \n            camera.update(0.016f);\n            performanceOptimizer.endFrame();\n        }, 2.0, String.format(\"Workload: %.1fms\", workloadMs));\n        \n        // Validate performance based on workload\n        double expectedFPS = 1000.0 / (workloadMs + 2.0); // Account for overhead\n        double tolerance = Math.max(5.0, expectedFPS * 0.1); // 10% tolerance or 5 FPS minimum\n        \n        if (expectedFPS >= PerformanceBenchmark.MINIMUM_FPS) {\n            assertTrue(result.getAverageFPS() >= expectedFPS - tolerance,\n                      String.format(\"FPS %.1f should be close to expected %.1f for %.1fms workload\", \n                                   result.getAverageFPS(), expectedFPS, workloadMs));\n        }\n        \n        // Heavy workloads should trigger adaptive quality\n        if (workloadMs >= 10.0) {\n            // Performance optimizer should have reduced quality\n            assertTrue(performanceOptimizer.getCurrentMSAALevel() < 3 || \n                      performanceOptimizer.getCurrentRenderScale() < 1.0f,\n                      \"Adaptive quality should activate under heavy workload\");\n        }\n        \n        logger.info(\"Variable workload test completed: {}\", result);\n    }\n    \n    /**\n     * Tests performance at different viewport resolutions.\n     */\n    @ParameterizedTest\n    @CsvSource({\"400,300\", \"800,600\", \"1200,900\", \"1920,1080\"})\n    @DisplayName(\"Resolution Scaling Performance\")\n    void testResolutionScalingPerformance(int width, int height) {\n        logger.info(\"Testing performance at {}x{} resolution\", width, height);\n        \n        FrameRateBenchmarkResult result = benchmark.measureFrameRate(() -> {\n            performanceOptimizer.beginFrame();\n            \n            mockOpenGLContext.beginFrame();\n            mockOpenGLContext.glViewport(0, 0, width, height);\n            \n            // Simulate resolution-dependent workload\n            double pixelCount = width * height;\n            double scaledWorkload = Math.max(1.0, pixelCount / 500000.0); // Base: 800x600\n            \n            try {\n                Thread.sleep((long) scaledWorkload);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            \n            mockOpenGLContext.glClear(0x00004100);\n            mockOpenGLContext.endFrame();\n            \n            // Update camera with resolution-dependent projection\n            camera.update(0.016f);\n            camera.getProjectionMatrix(width, height, 0.1f, 1000.0f);\n            \n            performanceOptimizer.endFrame();\n        }, 2.0, String.format(\"Resolution: %dx%d\", width, height));\n        \n        // Validate resolution scaling\n        PerformanceValidationResult validation = benchmark.validatePerformance(result);\n        \n        // Higher resolutions may have lower FPS, but should still be acceptable\n        if (width <= 1200) {\n            assertTrue(validation.isAcceptable(), \n                      \"Performance should be acceptable at moderate resolutions: \" + validation);\n        }\n        \n        // Very high resolutions should trigger adaptive scaling\n        if (width >= 1920) {\n            // Adaptive quality should activate\n            assertTrue(performanceOptimizer.getCurrentRenderScale() <= 1.0f,\n                      \"Render scale should be applied at high resolutions\");\n        }\n        \n        logger.info(\"Resolution scaling test completed: {}\", result);\n    }\n    \n    /**\n     * Tests adaptive quality system effectiveness.\n     */\n    @Test\n    @DisplayName(\"Adaptive Quality System\")\n    void testAdaptiveQualitySystem() {\n        logger.info(\"Testing adaptive quality system\");\n        \n        // Enable adaptive quality\n        performanceOptimizer.setAdaptiveQualityEnabled(true);\n        assertTrue(performanceOptimizer.isAdaptiveQualityEnabled(), \"Adaptive quality should be enabled\");\n        \n        // Test quality reduction under load\n        int initialMSAA = performanceOptimizer.getCurrentMSAALevel();\n        float initialScale = performanceOptimizer.getCurrentRenderScale();\n        \n        FrameRateBenchmarkResult heavyLoadResult = benchmark.measureFrameRate(() -> {\n            performanceOptimizer.beginFrame();\n            \n            // Simulate heavy rendering load\n            mockOpenGLContext.beginFrame();\n            try {\n                Thread.sleep(25); // 25ms - way over budget\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            mockOpenGLContext.endFrame();\n            \n            camera.update(0.016f);\n            performanceOptimizer.endFrame();\n        }, 5.0, \"Heavy load for adaptive quality\");\n        \n        // Verify adaptive quality activated\n        int finalMSAA = performanceOptimizer.getCurrentMSAALevel();\n        float finalScale = performanceOptimizer.getCurrentRenderScale();\n        \n        assertTrue(finalMSAA <= initialMSAA || finalScale <= initialScale,\n                  String.format(\"Adaptive quality should have reduced settings: MSAA %d->%d, Scale %.2f->%.2f\", \n                               initialMSAA, finalMSAA, initialScale, finalScale));\n        \n        // Test quality recovery under light load\n        performanceOptimizer.setMSAALevel(0); // Force lowest quality\n        performanceOptimizer.setRenderScale(0.5f);\n        performanceOptimizer.setAdaptiveQualityEnabled(true); // Re-enable adaptive\n        \n        FrameRateBenchmarkResult lightLoadResult = benchmark.measureFrameRate(() -> {\n            performanceOptimizer.beginFrame();\n            \n            // Minimal load\n            mockOpenGLContext.beginFrame();\n            try {\n                Thread.sleep(1); // Very light load\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            mockOpenGLContext.endFrame();\n            \n            camera.update(0.016f);\n            performanceOptimizer.endFrame();\n        }, 5.0, \"Light load for quality recovery\");\n        \n        // Quality should improve over time with good performance\n        int recoveredMSAA = performanceOptimizer.getCurrentMSAALevel();\n        float recoveredScale = performanceOptimizer.getCurrentRenderScale();\n        \n        assertTrue(recoveredMSAA > 0 || recoveredScale > 0.5f,\n                  String.format(\"Quality should recover under light load: MSAA %d, Scale %.2f\", \n                               recoveredMSAA, recoveredScale));\n        \n        logger.info(\"Adaptive quality system test completed successfully\");\n    }\n    \n    /**\n     * Tests memory usage efficiency and leak detection.\n     */\n    @Test\n    @DisplayName(\"Memory Usage Efficiency\")\n    void testMemoryUsageEfficiency() {\n        logger.info(\"Testing memory usage efficiency\");\n        \n        // Test memory usage during normal operation\n        MemoryBenchmarkResult normalUsage = benchmark.measureMemory(() -> {\n            performanceOptimizer.beginFrame();\n            \n            // Typical frame operations\n            mockOpenGLContext.beginFrame();\n            mockOpenGLContext.glViewport(0, 0, 800, 600);\n            camera.update(0.016f);\n            camera.getViewMatrix();\n            camera.getProjectionMatrix(800, 600, 0.1f, 1000.0f);\n            mockOpenGLContext.endFrame();\n            \n            performanceOptimizer.endFrame();\n        }, 1000, \"Normal operation memory usage\");\n        \n        // Validate memory efficiency\n        assertTrue(normalUsage.getAllocationRate() < 50000, // 50KB per millisecond\n                  \"Memory allocation rate should be efficient: \" + normalUsage.getAllocationRate());\n        \n        assertTrue(normalUsage.getRetainedMemory() < normalUsage.getTotalAllocated() * 0.1, // Less than 10% retained\n                  \"Memory retention should be low: retained=\" + normalUsage.getRetainedMemory() + \n                  \", total=\" + normalUsage.getTotalAllocated());\n        \n        // Test memory usage under stress\n        MemoryBenchmarkResult stressUsage = benchmark.measureMemory(() -> {\n            performanceOptimizer.beginFrame();\n            \n            // Stress operations - lots of matrix operations\n            for (int i = 0; i < 100; i++) {\n                camera.rotate(1.0f, 1.0f);\n                camera.update(0.001f); // Small update\n                camera.getViewMatrix();\n                camera.getProjectionMatrix(800 + i, 600 + i, 0.1f, 1000.0f);\n            }\n            \n            mockOpenGLContext.beginFrame();\n            mockOpenGLContext.glViewport(0, 0, 800, 600);\n            mockOpenGLContext.endFrame();\n            \n            performanceOptimizer.endFrame();\n        }, 100, \"Stress operation memory usage\");\n        \n        // Stress operations should not leak excessive memory\n        assertTrue(stressUsage.getRetainedMemory() < stressUsage.getTotalAllocated() * 0.2, // Less than 20% retained\n                  \"Memory retention under stress should be reasonable: retained=\" + stressUsage.getRetainedMemory() + \n                  \", total=\" + stressUsage.getTotalAllocated());\n        \n        // Test BufferManager memory tracking\n        if (bufferManager.getCurrentMemoryUsage() > 0) {\n            assertTrue(bufferManager.getCurrentMemoryUsage() < 50 * 1024 * 1024, // 50MB limit\n                      \"BufferManager memory usage should be reasonable: \" + \n                      bufferManager.getCurrentMemoryUsage());\n        }\n        \n        logger.info(\"Memory usage efficiency test completed: normal={}, stress={}\", \n                   normalUsage, stressUsage);\n    }\n    \n    /**\n     * Tests camera performance under various movement scenarios.\n     */\n    @Test\n    @DisplayName(\"Camera Performance\")\n    void testCameraPerformance() {\n        logger.info(\"Testing camera system performance\");\n        \n        // Test camera update performance\n        benchmark.measureSingle(() -> {\n            for (int i = 0; i < 1000; i++) {\n                camera.update(0.016f);\n            }\n        }, \"Camera update (1000 iterations)\");\n        \n        // Test matrix generation performance\n        benchmark.measureSingle(() -> {\n            for (int i = 0; i < 1000; i++) {\n                camera.getViewMatrix();\n                camera.getProjectionMatrix(800, 600, 0.1f, 1000.0f);\n            }\n        }, \"Matrix generation (1000 iterations)\");\n        \n        // Test camera movement performance\n        benchmark.measureSingle(() -> {\n            for (int i = 0; i < 1000; i++) {\n                camera.rotate(1.0f, 0.5f);\n                camera.zoom(0.1f);\n                camera.pan(1.0f, 1.0f);\n                camera.update(0.001f); // Small update step\n            }\n        }, \"Camera movement (1000 operations)\");\n        \n        // Test camera preset performance\n        benchmark.measureSingle(() -> {\n            ArcBallCamera.CameraPreset[] presets = ArcBallCamera.CameraPreset.values();\n            for (int i = 0; i < 100; i++) {\n                for (ArcBallCamera.CameraPreset preset : presets) {\n                    camera.applyPreset(preset);\n                    camera.update(0.1f); // Small update\n                }\n            }\n        }, \"Camera presets (700 applications)\");\n        \n        // Camera operations should be fast\n        var results = benchmark.getResults();\n        for (var result : results) {\n            if (result.getDescription().contains(\"Camera\")) {\n                assertTrue(result.getExecutionTimeMs() < 1000, // Less than 1 second for any camera test\n                          \"Camera operation should be fast: \" + result);\n            }\n        }\n        \n        logger.info(\"Camera performance test completed successfully\");\n    }\n    \n    /**\n     * Tests performance monitoring accuracy.\n     */\n    @Test\n    @DisplayName(\"Performance Monitoring Accuracy\")\n    void testPerformanceMonitoringAccuracy() {\n        logger.info(\"Testing performance monitoring accuracy\");\n        \n        // Test frame timing accuracy\n        FrameRateBenchmarkResult timedResult = benchmark.measureFrameRate(() -> {\n            performanceOptimizer.beginFrame();\n            \n            // Known workload\n            try {\n                Thread.sleep(16); // Target 60 FPS (16.67ms)\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            \n            performanceOptimizer.endFrame();\n        }, 3.0, \"Known 16ms workload\");\n        \n        // Frame rate should be close to expected\n        double expectedFPS = 1000.0 / 18.0; // 16ms + ~2ms overhead\n        assertTrue(Math.abs(timedResult.getAverageFPS() - expectedFPS) < 10.0,\n                  String.format(\"Measured FPS %.1f should be close to expected %.1f\", \n                               timedResult.getAverageFPS(), expectedFPS));\n        \n        // Test performance statistics\n        PerformanceOptimizer.PerformanceStatistics stats = performanceOptimizer.getStatistics();\n        assertNotNull(stats, \"Performance statistics should be available\");\n        assertTrue(stats.totalFrames > 0, \"Frame count should be tracked\");\n        assertTrue(stats.currentFPS > 0, \"Current FPS should be measured\");\n        \n        // Test performance warnings\n        if (!stats.warnings.isEmpty()) {\n            logger.info(\"Performance warnings detected: {}\", \n                       stats.warnings.stream().map(w -> w.message).toList());\n        }\n        \n        logger.info(\"Performance monitoring accuracy test completed: {}\", timedResult);\n    }\n    \n    /**\n     * Tests stress conditions and graceful degradation.\n     */\n    @Test\n    @DisplayName(\"Stress Test and Degradation\")\n    void testStressAndDegradation() {\n        logger.info(\"Testing stress conditions and graceful degradation\");\n        \n        // Test extreme workload\n        FrameRateBenchmarkResult stressResult = benchmark.measureFrameRate(() -> {\n            performanceOptimizer.beginFrame();\n            \n            mockOpenGLContext.beginFrame();\n            \n            // Extreme workload\n            try {\n                Thread.sleep(50); // 50ms - way over any reasonable budget\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            \n            // Multiple viewport changes\n            for (int i = 0; i < 10; i++) {\n                mockOpenGLContext.glViewport(0, 0, 800 + i * 10, 600 + i * 10);\n            }\n            \n            mockOpenGLContext.endFrame();\n            \n            // Excessive camera operations\n            for (int i = 0; i < 50; i++) {\n                camera.rotate(1.0f, 1.0f);\n                camera.update(0.001f);\n            }\n            \n            performanceOptimizer.endFrame();\n        }, 2.0, \"Extreme stress test\");\n        \n        // System should survive stress test\n        assertTrue(stressResult.getFrameCount() > 0, \"System should complete frames under stress\");\n        assertTrue(stressResult.getAverageFPS() >= 5.0, \"System should maintain minimum FPS under stress\");\n        \n        // Performance optimizer should have responded\n        assertTrue(performanceOptimizer.getCurrentMSAALevel() == 0 || \n                  performanceOptimizer.getCurrentRenderScale() < 1.0f,\n                  \"Adaptive quality should be at minimum under extreme stress\");\n        \n        // Test recovery after stress\n        performanceOptimizer.setAdaptiveQualityEnabled(true);\n        \n        FrameRateBenchmarkResult recoveryResult = benchmark.measureFrameRate(() -> {\n            performanceOptimizer.beginFrame();\n            \n            // Minimal workload for recovery\n            mockOpenGLContext.beginFrame();\n            try {\n                Thread.sleep(1);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            mockOpenGLContext.endFrame();\n            \n            camera.update(0.016f);\n            performanceOptimizer.endFrame();\n        }, 3.0, \"Recovery after stress\");\n        \n        // Performance should recover\n        assertTrue(recoveryResult.getAverageFPS() > stressResult.getAverageFPS(),\n                  \"Performance should recover after stress: stress=\" + stressResult.getAverageFPS() + \n                  \", recovery=\" + recoveryResult.getAverageFPS());\n        \n        logger.info(\"Stress test completed: stress={}, recovery={}\", stressResult, recoveryResult);\n    }\n}"