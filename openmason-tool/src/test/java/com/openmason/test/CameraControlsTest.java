package com.openmason.test;

import com.openmason.camera.ArcBallCamera;
import com.openmason.test.performance.PerformanceBenchmark;

import org.joml.Matrix4f;
import org.joml.Vector3f;
import org.junit.jupiter.api.*;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.EnumSource;
import org.junit.jupiter.params.provider.ValueSource;
import org.junit.jupiter.params.provider.CsvSource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Comprehensive test suite for professional camera controls validation.
 * 
 * Tests the ArcBall camera system for professional-grade functionality including:
 * - Precise mathematical operations and matrix calculations
 * - Smooth interpolation and animation system
 * - Professional camera presets and standard views
 * - Input handling and constraint enforcement
 * - Performance and responsiveness characteristics
 * - Integration with 3D viewport systems
 */
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class CameraControlsTest {
    
    private static final Logger logger = LoggerFactory.getLogger(CameraControlsTest.class);\n    \n    private ArcBallCamera camera;\n    private PerformanceBenchmark benchmark;\n    \n    // Test precision constants\n    private static final float FLOAT_PRECISION = 0.001f;\n    private static final float ANGLE_PRECISION = 0.1f;\n    private static final float MATRIX_PRECISION = 0.0001f;\n    \n    @BeforeAll\n    void setUpSuite() {\n        logger.info(\"Setting up Camera Controls Test Suite\");\n        benchmark = new PerformanceBenchmark(\"CameraControls\");\n    }\n    \n    @BeforeEach\n    void setUp() {\n        camera = new ArcBallCamera();\n        benchmark.clearResults();\n    }\n    \n    /**\n     * Tests camera initialization and default state.\n     */\n    @Test\n    @DisplayName(\"Camera Initialization\")\n    void testCameraInitialization() {\n        logger.info(\"Testing camera initialization\");\n        \n        // Test initial state\n        assertNotNull(camera, \"Camera should be initialized\");\n        \n        // Test default values match specification\n        assertEquals(45.0f, camera.getAzimuth(), ANGLE_PRECISION, \"Default azimuth\");\n        assertEquals(20.0f, camera.getElevation(), ANGLE_PRECISION, \"Default elevation\");\n        assertEquals(5.0f, camera.getDistance(), FLOAT_PRECISION, \"Default distance\");\n        assertEquals(45.0f, camera.getFOV(), ANGLE_PRECISION, \"Default FOV\");\n        \n        // Test initial target position\n        Vector3f target = camera.getTarget();\n        assertEquals(0.0f, target.x, FLOAT_PRECISION, \"Default target X\");\n        assertEquals(0.0f, target.y, FLOAT_PRECISION, \"Default target Y\");\n        assertEquals(0.0f, target.z, FLOAT_PRECISION, \"Default target Z\");\n        \n        // Test initial camera position calculation\n        Vector3f position = camera.getCameraPosition();\n        assertNotNull(position, \"Camera position should be calculated\");\n        assertTrue(position.length() > 0, \"Camera should be positioned away from origin\");\n        \n        // Test initial animation state\n        assertFalse(camera.isAnimating(), \"Camera should not be animating initially\");\n        \n        logger.info(\"Camera initialization test completed successfully\");\n    }\n    \n    /**\n     * Tests camera rotation mathematics and constraints.\n     */\n    @Test\n    @DisplayName(\"Camera Rotation Mathematics\")\n    void testCameraRotationMathematics() {\n        logger.info(\"Testing camera rotation mathematics\");\n        \n        // Test basic rotation\n        float initialAzimuth = camera.getAzimuth();\n        float initialElevation = camera.getElevation();\n        \n        camera.rotate(90.0f, 30.0f);\n        camera.update(10.0f); // Complete interpolation\n        \n        // Verify azimuth changed correctly (rotation sensitivity is 0.3 degrees per pixel)\n        float expectedAzimuth = initialAzimuth - (90.0f * 0.3f);\n        while (expectedAzimuth < 0) expectedAzimuth += 360;\n        while (expectedAzimuth >= 360) expectedAzimuth -= 360;\n        \n        assertEquals(expectedAzimuth, camera.getAzimuth(), 1.0f, \"Azimuth rotation calculation\");\n        \n        // Test elevation constraints\n        camera.setOrientation(0, 100.0f); // Above maximum\n        assertEquals(89.0f, camera.getElevation(), ANGLE_PRECISION, \"Maximum elevation constraint\");\n        \n        camera.setOrientation(0, -100.0f); // Below minimum\n        assertEquals(-89.0f, camera.getElevation(), ANGLE_PRECISION, \"Minimum elevation constraint\");\n        \n        // Test azimuth wraparound\n        camera.setOrientation(450.0f, 0); // Above 360\n        assertEquals(90.0f, camera.getAzimuth(), ANGLE_PRECISION, \"Azimuth wraparound (450° -> 90°)\");\n        \n        camera.setOrientation(-90.0f, 0); // Below 0\n        assertEquals(270.0f, camera.getAzimuth(), ANGLE_PRECISION, \"Azimuth wraparound (-90° -> 270°)\");\n        \n        logger.info(\"Camera rotation mathematics test completed successfully\");\n    }\n    \n    /**\n     * Tests camera zoom functionality and constraints.\n     */\n    @Test\n    @DisplayName(\"Camera Zoom Functionality\")\n    void testCameraZoomFunctionality() {\n        logger.info(\"Testing camera zoom functionality\");\n        \n        float initialDistance = camera.getDistance();\n        \n        // Test zoom in (positive delta)\n        camera.zoom(1.0f);\n        camera.update(10.0f); // Complete interpolation\n        \n        assertTrue(camera.getDistance() < initialDistance, \"Zoom in should decrease distance\");\n        \n        // Test zoom out (negative delta)\n        camera.zoom(-2.0f);\n        camera.update(10.0f);\n        \n        assertTrue(camera.getDistance() > initialDistance, \"Zoom out should increase distance\");\n        \n        // Test zoom constraints\n        camera.setDistance(0.05f); // Below minimum\n        assertEquals(0.1f, camera.getDistance(), FLOAT_PRECISION, \"Minimum distance constraint\");\n        \n        camera.setDistance(200.0f); // Above maximum\n        assertEquals(100.0f, camera.getDistance(), FLOAT_PRECISION, \"Maximum distance constraint\");\n        \n        // Test zoom sensitivity (1.15x per scroll step)\n        camera.setDistance(10.0f);\n        camera.zoom(1.0f);\n        camera.update(10.0f);\n        \n        float expectedDistance = 10.0f / 1.15f;\n        assertEquals(expectedDistance, camera.getDistance(), 0.1f, \"Zoom sensitivity calculation\");\n        \n        logger.info(\"Camera zoom functionality test completed successfully\");\n    }\n    \n    /**\n     * Tests camera panning with coordinate system accuracy.\n     */\n    @Test\n    @DisplayName(\"Camera Panning Accuracy\")\n    void testCameraPanningAccuracy() {\n        logger.info(\"Testing camera panning accuracy\");\n        \n        Vector3f initialTarget = new Vector3f(camera.getTarget());\n        \n        // Test horizontal panning\n        camera.pan(100.0f, 0.0f);\n        camera.update(10.0f);\n        \n        Vector3f afterHorizontalPan = camera.getTarget();\n        assertNotEquals(initialTarget, afterHorizontalPan, \"Horizontal pan should change target\");\n        \n        // Test vertical panning\n        camera.pan(0.0f, 100.0f);\n        camera.update(10.0f);\n        \n        Vector3f afterVerticalPan = camera.getTarget();\n        assertNotEquals(afterHorizontalPan, afterVerticalPan, \"Vertical pan should change target\");\n        \n        // Test pan sensitivity (0.002 world units per pixel)\n        camera.setTarget(new Vector3f(0, 0, 0));\n        camera.setDistance(5.0f);\n        \n        camera.pan(100.0f, 0.0f); // 100 pixels horizontal\n        camera.update(10.0f);\n        \n        Vector3f target = camera.getTarget();\n        float expectedOffset = 100.0f * 0.002f * 5.0f; // pixels * sensitivity * distance\n        \n        assertTrue(Math.abs(target.x) > 0.5f || Math.abs(target.z) > 0.5f, \n                  \"Pan should create noticeable target offset\");\n        \n        logger.info(\"Camera panning accuracy test completed successfully\");\n    }\n    \n    /**\n     * Tests all camera presets for correct positioning.\n     */\n    @ParameterizedTest\n    @EnumSource(ArcBallCamera.CameraPreset.class)\n    @DisplayName(\"Camera Presets Validation\")\n    void testCameraPresets(ArcBallCamera.CameraPreset preset) {\n        logger.info(\"Testing camera preset: {}\", preset.displayName);\n        \n        camera.applyPreset(preset);\n        camera.update(10.0f); // Complete interpolation\n        \n        // Verify preset angles\n        assertEquals(preset.azimuth, camera.getAzimuth(), ANGLE_PRECISION, \n                    \"Preset azimuth: \" + preset.displayName);\n        assertEquals(preset.elevation, camera.getElevation(), ANGLE_PRECISION, \n                    \"Preset elevation: \" + preset.displayName);\n        \n        // Test specific preset behaviors\n        switch (preset) {\n            case FRONT:\n                assertEquals(0.0f, camera.getAzimuth(), ANGLE_PRECISION, \"Front view azimuth\");\n                assertEquals(0.0f, camera.getElevation(), ANGLE_PRECISION, \"Front view elevation\");\n                break;\n                \n            case TOP:\n                assertEquals(0.0f, camera.getAzimuth(), ANGLE_PRECISION, \"Top view azimuth\");\n                assertEquals(90.0f, camera.getElevation(), ANGLE_PRECISION, \"Top view elevation\");\n                break;\n                \n            case ISOMETRIC:\n                assertEquals(45.0f, camera.getAzimuth(), ANGLE_PRECISION, \"Isometric azimuth\");\n                assertEquals(35.264f, camera.getElevation(), 0.1f, \"Isometric elevation\");\n                // Isometric preset should ensure reasonable distance\n                assertTrue(camera.getDistance() >= 3.0f, \"Isometric distance should be adequate\");\n                break;\n                \n            case LEFT:\n                assertEquals(-90.0f, normalizeAngle(camera.getAzimuth()), ANGLE_PRECISION, \"Left view azimuth\");\n                break;\n                \n            case RIGHT:\n                assertEquals(90.0f, camera.getAzimuth(), ANGLE_PRECISION, \"Right view azimuth\");\n                break;\n        }\n        \n        logger.debug(\"Preset {} applied: azimuth={}, elevation={}\", \n                    preset.displayName, camera.getAzimuth(), camera.getElevation());\n    }\n    \n    /**\n     * Tests matrix calculations for mathematical accuracy.\n     */\n    @Test\n    @DisplayName(\"Matrix Calculations Accuracy\")\n    void testMatrixCalculationsAccuracy() {\n        logger.info(\"Testing matrix calculations accuracy\");\n        \n        // Test view matrix generation\n        Matrix4f viewMatrix = camera.getViewMatrix();\n        assertNotNull(viewMatrix, \"View matrix should be generated\");\n        \n        // View matrix should be valid (determinant != 0)\n        float determinant = viewMatrix.determinant();\n        assertNotEquals(0.0f, determinant, MATRIX_PRECISION, \"View matrix should be invertible\");\n        \n        // Test projection matrix generation\n        Matrix4f projMatrix = camera.getProjectionMatrix(800, 600, 0.1f, 1000.0f);\n        assertNotNull(projMatrix, \"Projection matrix should be generated\");\n        \n        // Projection matrix should be valid\n        float projDeterminant = projMatrix.determinant();\n        assertNotEquals(0.0f, projDeterminant, MATRIX_PRECISION, \"Projection matrix should be invertible\");\n        \n        // Test aspect ratio handling\n        Matrix4f squareProj = camera.getProjectionMatrix(600, 600, 0.1f, 1000.0f);\n        Matrix4f wideProj = camera.getProjectionMatrix(1200, 600, 0.1f, 1000.0f);\n        \n        assertNotEquals(squareProj, wideProj, \"Projection matrices should differ with aspect ratio\");\n        \n        // Test camera position calculation consistency\n        Vector3f position1 = camera.getCameraPosition();\n        Vector3f position2 = camera.getCameraPosition();\n        \n        assertEquals(position1.x, position2.x, FLOAT_PRECISION, \"Position calculation should be consistent\");\n        assertEquals(position1.y, position2.y, FLOAT_PRECISION, \"Position calculation should be consistent\");\n        assertEquals(position1.z, position2.z, FLOAT_PRECISION, \"Position calculation should be consistent\");\n        \n        // Test view matrix consistency with camera movement\n        Matrix4f initialView = new Matrix4f(camera.getViewMatrix());\n        \n        camera.rotate(45.0f, 0);\n        camera.update(10.0f);\n        \n        Matrix4f rotatedView = camera.getViewMatrix();\n        assertNotEquals(initialView, rotatedView, \"View matrix should change with camera rotation\");\n        \n        logger.info(\"Matrix calculations accuracy test completed successfully\");\n    }\n    \n    /**\n     * Tests smooth interpolation system.\n     */\n    @Test\n    @DisplayName(\"Smooth Interpolation System\")\n    void testSmoothInterpolationSystem() {\n        logger.info(\"Testing smooth interpolation system\");\n        \n        // Test animation state\n        assertFalse(camera.isAnimating(), \"Camera should not be animating initially\");\n        \n        // Start animation\n        camera.rotate(90.0f, 0);\n        assertTrue(camera.isAnimating(), \"Camera should be animating after rotation command\");\n        \n        // Test gradual interpolation\n        float initialAzimuth = camera.getAzimuth();\n        \n        camera.update(0.1f); // Small time step\n        float partialAzimuth = camera.getAzimuth();\n        \n        camera.update(10.0f); // Large time step to complete\n        float finalAzimuth = camera.getAzimuth();\n        \n        // Verify interpolation progression\n        assertTrue(Math.abs(partialAzimuth - initialAzimuth) < Math.abs(finalAzimuth - initialAzimuth),\n                  \"Interpolation should progress gradually\");\n        \n        // Test interpolation for all movement types\n        camera.setOrientation(0, 0);\n        camera.setDistance(5.0f);\n        camera.setTarget(new Vector3f(0, 0, 0));\n        \n        // Simultaneous movements\n        camera.rotate(45.0f, 30.0f);\n        camera.zoom(1.0f);\n        camera.pan(50.0f, 50.0f);\n        \n        assertTrue(camera.isAnimating(), \"Camera should animate multiple simultaneous movements\");\n        \n        // Complete all animations\n        camera.update(10.0f);\n        \n        // Verify final state is reasonable\n        assertTrue(camera.getDistance() > 0, \"Distance should be positive after animation\");\n        assertNotNull(camera.getTarget(), \"Target should be valid after animation\");\n        assertNotNull(camera.getCameraPosition(), \"Position should be valid after animation\");\n        \n        logger.info(\"Smooth interpolation system test completed successfully\");\n    }\n    \n    /**\n     * Tests frame object functionality.\n     */\n    @ParameterizedTest\n    @CsvSource({\n        \"-1,-1,-1,1,1,1\",    // Unit cube centered at origin\n        \"-5,-3,-2,5,7,8\",    // Irregular box\n        \"0,0,0,10,10,10\",   // Large cube at origin\n        \"-2,5,-1,-1,6,0\"     // Small box in positive quadrant\n    })\n    @DisplayName(\"Frame Object Functionality\")\n    void testFrameObjectFunctionality(float minX, float minY, float minZ, \n                                     float maxX, float maxY, float maxZ) {\n        logger.info(\"Testing frame object: ({},{},{}) to ({},{},{})\", \n                   minX, minY, minZ, maxX, maxY, maxZ);\n        \n        Vector3f min = new Vector3f(minX, minY, minZ);\n        Vector3f max = new Vector3f(maxX, maxY, maxZ);\n        \n        camera.frameObject(min, max);\n        camera.update(10.0f); // Complete animation\n        \n        // Calculate expected center\n        Vector3f expectedCenter = new Vector3f(min).add(max).mul(0.5f);\n        Vector3f actualTarget = camera.getTarget();\n        \n        // Verify camera target is at center of bounding box\n        assertEquals(expectedCenter.x, actualTarget.x, FLOAT_PRECISION, \"Target X should be at center\");\n        assertEquals(expectedCenter.y, actualTarget.y, FLOAT_PRECISION, \"Target Y should be at center\");\n        assertEquals(expectedCenter.z, actualTarget.z, FLOAT_PRECISION, \"Target Z should be at center\");\n        \n        // Verify distance is appropriate for object size\n        Vector3f size = new Vector3f(max).sub(min);\n        float maxDimension = Math.max(Math.max(size.x, size.y), size.z);\n        \n        assertTrue(camera.getDistance() > maxDimension * 0.5f, \n                  \"Camera should be far enough to see entire object\");\n        assertTrue(camera.getDistance() < maxDimension * 5.0f, \n                  \"Camera should not be excessively far from object\");\n        \n        logger.debug(\"Frame object completed: center={}, distance={}, size={}\", \n                    actualTarget, camera.getDistance(), maxDimension);\n    }\n    \n    /**\n     * Tests camera reset functionality.\n     */\n    @Test\n    @DisplayName(\"Camera Reset Functionality\")\n    void testCameraResetFunctionality() {\n        logger.info(\"Testing camera reset functionality\");\n        \n        // Modify camera state significantly\n        camera.rotate(180.0f, 45.0f);\n        camera.zoom(3.0f);\n        camera.pan(200.0f, 150.0f);\n        camera.changeFOV(20.0f);\n        camera.update(10.0f); // Apply changes\n        \n        // Verify camera is in modified state\n        assertNotEquals(45.0f, camera.getAzimuth(), 1.0f, \"Camera should be in modified state\");\n        assertNotEquals(5.0f, camera.getDistance(), 0.1f, \"Camera should be in modified state\");\n        \n        // Reset camera\n        camera.reset();\n        camera.update(10.0f); // Complete reset animation\n        \n        // Verify reset to default values\n        assertEquals(45.0f, camera.getAzimuth(), ANGLE_PRECISION, \"Azimuth should reset to default\");\n        assertEquals(20.0f, camera.getElevation(), ANGLE_PRECISION, \"Elevation should reset to default\");\n        assertEquals(5.0f, camera.getDistance(), FLOAT_PRECISION, \"Distance should reset to default\");\n        assertEquals(45.0f, camera.getFOV(), ANGLE_PRECISION, \"FOV should reset to default\");\n        \n        // Verify target reset\n        Vector3f target = camera.getTarget();\n        assertEquals(0.0f, target.x, FLOAT_PRECISION, \"Target X should reset to origin\");\n        assertEquals(0.0f, target.y, FLOAT_PRECISION, \"Target Y should reset to origin\");\n        assertEquals(0.0f, target.z, FLOAT_PRECISION, \"Target Z should reset to origin\");\n        \n        logger.info(\"Camera reset functionality test completed successfully\");\n    }\n    \n    /**\n     * Tests camera performance characteristics.\n     */\n    @Test\n    @DisplayName(\"Camera Performance Characteristics\")\n    void testCameraPerformanceCharacteristics() {\n        logger.info(\"Testing camera performance characteristics\");\n        \n        // Test update performance\n        benchmark.measureSingle(() -> {\n            for (int i = 0; i < 10000; i++) {\n                camera.update(0.016f);\n            }\n        }, \"Camera update (10,000 iterations)\");\n        \n        // Test matrix generation performance\n        benchmark.measureSingle(() -> {\n            for (int i = 0; i < 10000; i++) {\n                camera.getViewMatrix();\n                camera.getProjectionMatrix(800, 600, 0.1f, 1000.0f);\n            }\n        }, \"Matrix generation (10,000 iterations)\");\n        \n        // Test movement operations performance\n        benchmark.measureSingle(() -> {\n            for (int i = 0; i < 1000; i++) {\n                camera.rotate(1.0f, 1.0f);\n                camera.zoom(0.1f);\n                camera.pan(1.0f, 1.0f);\n            }\n        }, \"Movement operations (1,000 iterations)\");\n        \n        // Verify performance requirements\n        var results = benchmark.getResults();\n        for (var result : results) {\n            assertTrue(result.getExecutionTimeMs() < 1000, // All operations under 1 second\n                      \"Camera operation should be fast: \" + result.getDescription() + \n                      \" took \" + result.getExecutionTimeMs() + \"ms\");\n        }\n        \n        logger.info(\"Camera performance characteristics test completed successfully\");\n    }\n    \n    /**\n     * Tests FOV (Field of View) functionality.\n     */\n    @ParameterizedTest\n    @ValueSource(floats = {10.0f, 30.0f, 45.0f, 60.0f, 90.0f, 120.0f})\n    @DisplayName(\"Field of View Functionality\")\n    void testFieldOfViewFunctionality(float targetFOV) {\n        logger.info(\"Testing FOV functionality: {}°\", targetFOV);\n        \n        float initialFOV = camera.getFOV();\n        float fovDelta = targetFOV - initialFOV;\n        \n        camera.changeFOV(fovDelta);\n        camera.update(10.0f);\n        \n        // Verify FOV within constraints (5° to 120°)\n        float expectedFOV = Math.max(5.0f, Math.min(120.0f, targetFOV));\n        assertEquals(expectedFOV, camera.getFOV(), ANGLE_PRECISION, \"FOV should be set correctly\");\n        \n        // Test FOV affects projection matrix\n        Matrix4f proj1 = camera.getProjectionMatrix(800, 600, 0.1f, 1000.0f);\n        \n        camera.changeFOV(10.0f); // Change FOV\n        camera.update(10.0f);\n        \n        Matrix4f proj2 = camera.getProjectionMatrix(800, 600, 0.1f, 1000.0f);\n        \n        if (camera.getFOV() != expectedFOV) { // Only if FOV actually changed\n            assertNotEquals(proj1, proj2, \"Projection matrix should change with FOV\");\n        }\n        \n        logger.debug(\"FOV test completed: target={}, actual={}\", targetFOV, camera.getFOV());\n    }\n    \n    // Helper methods\n    \n    private float normalizeAngle(float angle) {\n        while (angle < 0) angle += 360;\n        while (angle >= 360) angle -= 360;\n        return angle;\n    }\n}"